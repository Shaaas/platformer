<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Super Platformer: Solid Edition</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; }
  canvas { display: block; margin: 0 auto; background: #87ceeb; border: 4px solid #333; }
  #ui-layer {
    position: absolute; top: 15px; left: 15px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    pointer-events: none; width: 100%;
  }
  #restartBtn {
    position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
    padding: 15px 30px; font-size: 24px; display: none; cursor: pointer;
    background: #ff4757; color: white; border: none; border-radius: 8px; font-weight: bold;
  }
</style>
</head>
<body>
<div id="ui-layer">
  <div style="font-size: 26px; font-weight: bold;">Score: <span id="scoreVal">0</span></div>
  <div style="font-size: 18px;">Level: <span id="lvlVal">1</span></div>
  <div id="powerStatus" style="font-size: 14px; color: #00ff00;"></div>
</div>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<button id="restartBtn">RETRY FROM CHECKPOINT</button>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const restartBtn = document.getElementById('restartBtn');
const scoreVal = document.getElementById('scoreVal');
const lvlVal = document.getElementById('lvlVal');
const powerStatus = document.getElementById('powerStatus');

// --- ASSETS ---
const assets = { 
    player: new Image(), platform: new Image(), coin: new Image(), 
    enemy: new Image(), bg: new Image(), checkpoint: new Image(),
    powerup: new Image()
};
assets.player.src = 'player.png';
assets.platform.src = 'platform.png';
assets.coin.src = 'coin.png';
assets.enemy.src = 'enemy.png';
assets.bg.src = 'background.png';
assets.checkpoint.src = 'checkpoint.png';
assets.powerup.src = 'powerup.png';

let score = 0;
let gameOver = false;
let currentLevel = 0;
let ghosts = [];

const player = {
  x:50, y:200, w:40, h:50,
  dx:0, dy:0, speed:6, jumpPower:12, 
  onGround:false, jumpsLeft: 2,
  dashCooldown: 0, isDashing: 0, facing: 1,
  invincible: 0, 
  checkpoint: { x: 50, y: 200 }
};

const levels = [
  {
    platforms: [
        {x:0, y:350, w:300, h:50, type:'static'},
        {x:450, y:350, w:350, h:50, type:'static'},
        {x:320, y:240, w:100, h:25, type:'static'}, // Solid replacement for the falling one
        {x:500, y:180, w:120, h:25, type:'moving', range:100, basePos: 500}
    ],
    items: [
        {x:250, y:310, w:30, h:30, type:'coin', active:true},
        {x:540, y:130, w:30, h:30, type:'powerup', active:true},
        {x:460, y:300, w:40, h:50, type:'checkpoint', active:true}
    ],
    enemies: [{x:600, y:315, w:35, h:35, dx:2, L:450, R:750}],
    endX: 780
  }
];

let state = { platforms: [], items: [], enemies: [] };

function loadLevel(idx, fromCheckpoint = false) {
  const level = levels[idx] || levels[0];
  state.platforms = JSON.parse(JSON.stringify(level.platforms));
  state.items = JSON.parse(JSON.stringify(level.items));
  state.enemies = JSON.parse(JSON.stringify(level.enemies));
  
  if(fromCheckpoint) {
      player.x = player.checkpoint.x;
      player.y = player.checkpoint.y;
  } else {
      player.x = 50; player.y = 200;
      player.checkpoint = { x: 50, y: 200 };
  }
  
  player.dx = 0; player.dy = 0;
  player.invincible = 0;
  gameOver = false;
  restartBtn.style.display = 'none';
  lvlVal.innerText = idx + 1;
}

const keys = {};
window.addEventListener('keydown', e => {
    if (!gameOver && (e.code === 'Space' || e.code === 'ArrowUp') && player.jumpsLeft > 0) {
        player.dy = -player.jumpPower; player.jumpsLeft--; player.onGround = false;
    }
    if (!gameOver && (e.code === 'ShiftLeft') && player.dashCooldown <= 0) {
        player.isDashing = 10; player.dashCooldown = 40;
    }
    keys[e.code] = true;
});
window.addEventListener('keyup', e => keys[e.code] = false);

function update() {
  if(gameOver) return;

  if(keys['ArrowRight']) { player.dx = player.speed; player.facing = 1; }
  else if(keys['ArrowLeft']) { player.dx = -player.speed; player.facing = -1; }
  else player.dx *= 0.8;

  if (player.isDashing > 0) {
    player.dx = player.facing * 15; player.dy = 0; player.isDashing--;
    ghosts.push({x: player.x, y: player.y, life: 10});
  } else { player.dy += 0.7; }
  
  player.x += player.dx; player.y += player.dy;
  if(player.dashCooldown > 0) player.dashCooldown--;
  if(player.invincible > 0) {
      player.invincible--;
      powerStatus.innerText = "POWERED UP: " + Math.ceil(player.invincible/60) + "s";
  } else { powerStatus.innerText = ""; }

  player.onGround = false;
  state.platforms.forEach(p => {
    if(p.type === 'moving') {
        let oldX = p.x;
        p.x = p.basePos + Math.sin(Date.now() / 600) * p.range;
        if(player.onGround && player.y + player.h === p.y) player.x += (p.x - oldX);
    }

    if(player.x < p.x + p.w && player.x + player.w > p.x &&
       player.y + player.h > p.y && player.y + player.h < p.y + p.h + player.dy) {
        player.y = p.y - player.h; player.dy = 0; player.onGround = true; player.jumpsLeft = 2;
    }
  });

  state.items.forEach(item => {
    if(item.active && player.x < item.x + item.w && player.x + player.w > item.x && player.y < item.y + item.h && player.y + player.h > item.y) {
        if(item.type === 'coin') { item.active = false; score += 100; scoreVal.innerText = score; }
        if(item.type === 'powerup') { item.active = false; player.invincible = 300; }
        if(item.type === 'checkpoint') { item.active = false; player.checkpoint = {x: item.x, y: item.y - 10}; }
    }
  });

  state.enemies.forEach((e, i) => {
    e.x += e.dx; if(e.x < e.L || e.x + e.w > e.R) e.dx *= -1;
    if(player.x < e.x + e.w && player.x + player.w > e.x && player.y < e.y + e.h && player.y + player.h > e.y) {
      if(player.dy > 0 || player.invincible > 0) {
        state.enemies.splice(i, 1); player.dy = -10; score += 200; scoreVal.innerText = score;
      } else { gameOver = true; restartBtn.style.display = 'block'; }
    }
  });

  if(player.y > canvas.height) { gameOver = true; restartBtn.style.display = 'block'; }
  if(player.x > levels[currentLevel].endX) { currentLevel++; loadLevel(currentLevel); }
  ghosts.forEach((g, i) => { g.life--; if(g.life <= 0) ghosts.splice(i, 1); });
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  let bgScroll = (player.x * 0.1) % canvas.width;
  ctx.drawImage(assets.bg, -bgScroll, 0, canvas.width, canvas.height);
  ctx.drawImage(assets.bg, -bgScroll + canvas.width, 0, canvas.width, canvas.height);

  ctx.fillStyle = '#ff4500'; ctx.fillRect(0, canvas.height-20, canvas.width, 20);

  state.platforms.forEach(p => ctx.drawImage(assets.platform, p.x, p.y, p.w, p.h));
  state.items.forEach(item => {
    if(!item.active && item.type !== 'checkpoint') return;
    ctx.drawImage(assets[item.type], item.x, item.y, item.w, item.h);
  });
  state.enemies.forEach(e => ctx.drawImage(assets.enemy, e.x, e.y, e.w, e.h));

  ghosts.forEach(g => { ctx.globalAlpha = 0.3; ctx.drawImage(assets.player, g.x, g.y, player.w, player.h); });
  ctx.globalAlpha = 1.0;
  if(player.invincible > 0) ctx.filter = `hue-rotate(${Date.now()%360}deg) contrast(1.5)`;
  ctx.drawImage(assets.player, player.x, player.y, player.w, player.h);
  ctx.filter = 'none';

  if(gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = "bold 32px Arial";
      ctx.fillText('RETRY FROM LAST CHECKPOINT?', 400, 200);
  }
}

restartBtn.addEventListener('click', () => loadLevel(currentLevel, true));
function loop() { update(); draw(); requestAnimationFrame(loop); }
loadLevel(0);
loop();
</script>
</body>
</html>
